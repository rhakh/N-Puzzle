diff --git a/src/CSCP.cpp b/src/CSCP.cpp
index 9f06c34..26bb838 100644
--- a/src/CSCP.cpp
+++ b/src/CSCP.cpp
@@ -11,7 +11,7 @@
 
 void	CSCP::constructTaskResponse(size_t openNodes, size_t closedNodes,
 								size_t usedMemory, double elapsedTime,
-								std::list<uint8_t> &result,
+								std::list<int> &result,
 								std::string &resultStr) {
 	namespace pt = boost::property_tree;
 
@@ -67,11 +67,11 @@ void	CSCP::taskHandler(boost::property_tree::ptree &json, std::string &resultStr
 	std::tuple<size_t, size_t, size_t>	retVal;
 	pt::ptree		mapNode = json.get_child("data.map");
 	pt::ptree		dataNode = json.get_child("data");
-	unsigned char	map[mapNode.size()];
+	int	map[mapNode.size()];
 	unsigned int	openNodes = 0, closedNodes = 0, usedMemory = 0;
 	int				i;
 	clock_t			start;
-	std::list<uint8_t>	result;
+	std::list<int>	result;
 
 	pt::ptree::iterator		it = mapNode.begin();
 	for (i = 0; it != mapNode.end(); it++, i++)
diff --git a/src/CSCP.hpp b/src/CSCP.hpp
index e1cfd10..c1cdc26 100644
--- a/src/CSCP.hpp
+++ b/src/CSCP.hpp
@@ -20,7 +20,7 @@ class CSCP {
 
 	void	constructTaskResponse(size_t openNodes, size_t closedNodes,
 									size_t usedMemory, double elapsedTime,
-									std::list<uint8_t> &result,
+									std::list<int> &result,
 									std::string &resultStr);
 	void	constructErrorResponse(std::exception &e, std::string &resultStr);
 	void	taskHandler(boost::property_tree::ptree &json, std::string &resultStr);
diff --git a/src/NPuzzleSolver.cpp b/src/NPuzzleSolver.cpp
index 8c2f177..25aa255 100644
--- a/src/NPuzzleSolver.cpp
+++ b/src/NPuzzleSolver.cpp
@@ -11,7 +11,7 @@
 typedef std::priority_queue<State *, std::vector<State *>, CompareState>	NPqueue;
 typedef std::unordered_set<State *, HashState, EqualState>	NPset;
 
-void	NPuzzleSolver::checkPath(const State *root, const std::list<uint8_t> &result) const {
+void	NPuzzleSolver::checkPath(const State *root, const std::list<int> &result) const {
 	std::string ss[] = {"ROOT", "UP", "DOWN", "LEFT", "RIGHT"};
 	State *state;
 	State *prev = nullptr;
@@ -49,7 +49,7 @@ void    freeMem(NPqueue *open, NPset *closed, State *last) {
 		delete last;
 }
 
-void 	NPuzzleSolver::createPath(std::list<uint8_t> &result, const State *curr) const {
+void 	NPuzzleSolver::createPath(std::list<int> &result, const State *curr) const {
 	while (curr->getMove() != ROOT) {
 		result.push_front(curr->getMove());
 		curr = curr->getPrev();
@@ -62,12 +62,12 @@ constructRetVal(NPqueue *open, NPset *closed, unsigned int maxOpen) {
 	size_t	summ = open->size() + closed->size();
 
 	// used memory
-	summ = summ * (sizeof(State) + sizeof(uint8_t) * State::mapSize);
+	summ = summ * (sizeof(State) + sizeof(int) * State::mapSize);
 	return (std::make_tuple(maxOpen, closed->size(), summ));
 }
 
 std::tuple<size_t, size_t, size_t>
-NPuzzleSolver::aStar(const uint8_t *map, uint8_t mapSize, int solutionType, std::list<uint8_t> &result) {
+NPuzzleSolver::aStar(const int *map, int mapSize, int solutionType, std::list<int> &result) {
 	std::tuple<size_t, size_t, size_t>	retVal;
 	NPqueue	open;
 	NPset	closed;
@@ -150,7 +150,7 @@ NPuzzleSolver::~NPuzzleSolver() {
 
 }
 
-bool	isSolvableForNormal(const uint8_t *map, uint8_t mapSize) {
+bool	isSolvableForNormal(const int *map, int mapSize) {
 	int	inversions = 0;
 	int size = (int)std::sqrt(mapSize);
 	int zeroY = -1;
@@ -178,7 +178,7 @@ bool	isSolvableForNormal(const uint8_t *map, uint8_t mapSize) {
 		return ((zeroY % 2 != 0) == (inversions % 2 == 0));
 }
 
-bool NPuzzleSolver::isSolvable(const uint8_t *map, uint8_t mapSize, int solutionType) {
+bool NPuzzleSolver::isSolvable(const int *map, int mapSize, int solutionType) {
 	if (solutionType == NORMAL_SOLUTION)
 		return (isSolvableForNormal(map, mapSize));
 	else
@@ -187,7 +187,7 @@ bool NPuzzleSolver::isSolvable(const uint8_t *map, uint8_t mapSize, int solution
 
 std::tuple<size_t, size_t, size_t>
 NPuzzleSolver::solve(int func, int algo, int solutionType,
-		const uint8_t *map, uint8_t mapSize, std::list<uint8_t> &result) {
+		const int *map, int mapSize, std::list<int> &result) {
 
 	if (mapSize < 9)
 		throw NP_InvalidMapSize();
diff --git a/src/NPuzzleSolver.hpp b/src/NPuzzleSolver.hpp
index 5dc3299..8911335 100644
--- a/src/NPuzzleSolver.hpp
+++ b/src/NPuzzleSolver.hpp
@@ -23,26 +23,26 @@ class NPuzzleSolver
 {
 	State				*finishState;
 
-	int		(*heuristicFunc)(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize);
+	int		(*heuristicFunc)(const int *map, const int *finishMap, int mapSize);
 
 	// algo functions
 	std::tuple<size_t, size_t, size_t>
-		aStar(const uint8_t *map, uint8_t mapSize, int solutionType, std::list<uint8_t> &result);
+		aStar(const int *map, int mapSize, int solutionType, std::list<int> &result);
 	std::tuple<size_t, size_t, size_t>
-		aStarIDA(const uint8_t *map, uint8_t mapSize, int solutionType, std::list<uint8_t> &result);
+		aStarIDA(const int *map, int mapSize, int solutionType, std::list<int> &result);
 
-	void 	createPath(std::list<uint8_t> &result, const State *curr) const;
-	State	*doMove(const State *curr, uint8_t move);
-	State	*getNewState(const State *curr, int emptyPos, int newPos, uint8_t move);
+	void 	createPath(std::list<int> &result, const State *curr) const;
+	State	*doMove(const State *curr, int move);
+	State	*getNewState(const State *curr, int emptyPos, int newPos, int move);
 
 	// use to check path if it's correct
-	void	checkPath(const State *root, const std::list<uint8_t> &result) const;
-	bool	isSolvable(const uint8_t *map, uint8_t mapSize, int solutionType);
+	void	checkPath(const State *root, const std::list<int> &result) const;
+	bool	isSolvable(const int *map, int mapSize, int solutionType);
 
 public:
 	std::tuple<size_t, size_t, size_t>
 	solve(int func, int algo, int solutionType,
-			const uint8_t *map, uint8_t mapSize, std::list<uint8_t> &result);
+			const int *map, int mapSize, std::list<int> &result);
 
 	NPuzzleSolver();
 	~NPuzzleSolver();
diff --git a/src/State.cpp b/src/State.cpp
index efc3ff3..399a037 100644
--- a/src/State.cpp
+++ b/src/State.cpp
@@ -7,15 +7,15 @@
 int State::size = 4;
 int State::mapSize = State::size * State::size;
 
-auto findIndexInMap = [](uint8_t value, const uint8_t *map, uint8_t mapSize) {
+auto findIndexInMap = [](int value, const int *map, int mapSize) {
 	for (int i = 0; i < mapSize; i++)
 		if (map[i] == value)
 			return (i);
 	return (-1);
 };
 
-State::State(const uint8_t *map, int price, int length) {
-	this->map = new uint8_t[State::mapSize];
+State::State(const int *map, int price, int length) {
+	this->map.reserve(State::mapSize);
 
 	for (int i = 0; i < State::mapSize; i++)
 		this->map[i] = map[i];
@@ -34,7 +34,7 @@ void	State::makeSnailState() {
 	int	dirCh = 0;
 	int	vis = State::size;
 
-	uint8_t matr[State::size][State::size];
+	int matr[State::size][State::size];
 
 	for (int i = 0; i < State::mapSize; i++) {
 		matr[row][col] = i + 1;
@@ -53,7 +53,7 @@ void	State::makeSnailState() {
 	}
 
 	int m = 0;
-	this->map = new uint8_t[State::mapSize];
+	map.reserve(State::mapSize);
 	for (int i = 0; i < State::size; i++)
 		for (int j = 0; j < State::size; j++)
 			this->map[m++] = matr[i][j];
@@ -65,7 +65,7 @@ void	State::makeSnailState() {
 }
 
 void	State::makeNormalState() {
-	this->map = new uint8_t[State::mapSize];
+	map.reserve(State::mapSize);
 	for (int i = 0; i < State::mapSize; i++)
 		this->map[i] = i + 1;
 	this->map[State::mapSize - 1] = 0;
@@ -84,7 +84,7 @@ State::State(int solutionType) {
 }
 
 State::State(const State &src, int move) {
-	const uint8_t	*map = src.getMapPtr();
+	const int	*map = src.getMapPtr();
 
 	const int	size = State::size;
 	int			x, y, newPos, zeroIndex;
@@ -123,7 +123,7 @@ State::State(const State &src, int move) {
 			break;
 	}
 
-	this->map = new uint8_t[State::mapSize];
+	this->map.reserve(State::mapSize);
 	for (int i = 0; i < State::mapSize; i++)
 		this->map[i] = map[i];
 	this->swapPieces(zeroIndex, newPos);
@@ -134,7 +134,7 @@ State::State(const State &src, int move) {
 	this->prev = &src;
 }
 
-uint8_t	State::getMove() const {
+int	State::getMove() const {
 	return (this->movement);
 }
 
@@ -142,22 +142,20 @@ const State	*State::getPrev() const {
 	return (this->prev);
 }
 
-State::~State() {
-	delete[] this->map;
-}
+State::~State() {}
 
 void	State::printState() const {
 	printf("State price = %d, length = %d\n", this->price, this->length);
-	if (this->map != nullptr) {
+	// if (this->map != nullptr) {
 		for (int i = 0; i < State::mapSize; i++) {
 			if ((i + 1) % State::size == 0)
 				printf("%2u\n", this->map[i]);
 			else
 				printf("%2u ", this->map[i]);
 		}
-	}
-	else
-		printf("map is null\n");
+	// }
+	// else
+		// printf("map is null\n");
 	printf("\n\n");
 }
 
@@ -168,7 +166,7 @@ void	State::swapPieces(int a, int b) {
 size_t HashState::operator()(const State* a) const {
 	size_t	seed = State::mapSize;
 
-	const uint8_t	*map = a->getMapPtr();
+	const int	*map = a->getMapPtr();
 
 	for(int i = 0; i < State::mapSize; i++) {
 		seed ^= map[i] + 0x9e3779b9 + (seed << 6) + (seed >> 2);
@@ -185,8 +183,8 @@ bool CompareState::operator()(const State *a, const State *b) {
 }
 
 bool EqualState::operator()(const State *lhs, const State *rhs) const {
-	const uint8_t *pa = rhs->getMapPtr();
-	const uint8_t *pb = lhs->getMapPtr();
+	const int *pa = rhs->getMapPtr();
+	const int *pb = lhs->getMapPtr();
 
 	for (int i = 0; i < State::mapSize; i++) {
 		if (pa[i] != pb[i])
diff --git a/src/State.hpp b/src/State.hpp
index e2321b1..199c1ae 100644
--- a/src/State.hpp
+++ b/src/State.hpp
@@ -3,6 +3,7 @@
 
 #include <cstdint>
 #include <iostream>
+#include <vector>
 
 enum moves_e {ROOT, UP, DOWN, LEFT, RIGHT, LAST};
 
@@ -15,10 +16,11 @@ public:
 	static int	mapSize;
 
 private:
-	uint8_t	*map = nullptr;
+	// int	*map = nullptr;
+	std::vector<int>	map;
 	int		price;
 	int		length;
-	uint8_t	movement;
+	int		movement;
 	const State	*prev;
 
 	//disable copy constructor;
@@ -29,7 +31,7 @@ private:
 	void	makeNormalState();
 
 public:
-	State(const uint8_t *map, int price, int length);
+	State(const int *map, int price, int length);
 	State(int solutionType); //build finish state
 	State(const State &src, int move);
 	~State();
@@ -38,10 +40,10 @@ public:
 	void			setPrice(int price) { this->price = price; }
 	int				getLength() const { return (this->length); }
 	int				getPrice() const { return (this->price); }
-	const uint8_t	*getMapPtr() const { return (this->map); }
+	const int		*getMapPtr() const { return (this->map.data()); }
 	void			printState() const;
 	void			swapPieces(int a, int b);
-	uint8_t			getMove() const;
+	int				getMove() const;
 	const State		*getPrev() const;
 
 	class	NP_InvalidMove : public std::exception {
diff --git a/src/heuristicFunctions.cpp b/src/heuristicFunctions.cpp
index 0f9de5a..6f1dbf8 100644
--- a/src/heuristicFunctions.cpp
+++ b/src/heuristicFunctions.cpp
@@ -3,14 +3,14 @@
 #include <iostream>
 #include <functional>
 
-auto findIndexInMap = [](uint8_t value, const uint8_t *map, uint8_t mapSize) {
+auto findIndexInMap = [](int value, const int *map, int mapSize) {
 	for (int i = 0; i < mapSize; i++)
 		if (map[i] == value)
 			return (i);
 	return (-1);
 };
 
-int	misplacedTiles(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize) {
+int	misplacedTiles(const int *map, const int *finishMap, int mapSize) {
 	int inversions = 0;
 
 	for (int i = 0; i < mapSize; i++) {
@@ -20,9 +20,9 @@ int	misplacedTiles(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize
 	return (inversions);
 }
 
-int	manhattanDistance(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize) {
+int	manhattanDistance(const int *map, const int *finishMap, int mapSize) {
 	int	price = 0;
-	uint8_t	x1, x2, y1, y2, xres, yres, j;
+	int	x1, x2, y1, y2, xres, yres, j;
 
 	for (int i = 0; i < mapSize; i++) {
 		if (map[i]) {
@@ -47,8 +47,8 @@ int	manhattanDistance(const uint8_t *map, const uint8_t *finishMap, uint8_t mapS
 	return (price);
 }
 
-static int linearConflicts(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize) {
-	uint8_t	linearConflicts = 0;
+static int linearConflicts(const int *map, const int *finishMap, int mapSize) {
+	int	linearConflicts = 0;
 
 	// conflicts in rows
 	for (int row = 0; row < State::size; row++) {
@@ -75,17 +75,17 @@ static int linearConflicts(const uint8_t *map, const uint8_t *finishMap, uint8_t
 	return (linearConflicts);
 }
 
-int	MDplusLinearConflicts(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize) {
+int	MDplusLinearConflicts(const int *map, const int *finishMap, int mapSize) {
 	return (manhattanDistance(map, finishMap, mapSize) + linearConflicts(map, finishMap, mapSize));
 }
 
-int	MTplusLinearConflicts(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize) {
+int	MTplusLinearConflicts(const int *map, const int *finishMap, int mapSize) {
 	return (misplacedTiles(map, finishMap, mapSize) + linearConflicts(map, finishMap, mapSize));
 }
 
-int	nMaxSwap(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize) {
+int	nMaxSwap(const int *map, const int *finishMap, int mapSize) {
 
-	uint8_t	mapCopy[mapSize];
+	int	mapCopy[mapSize];
 	int retVal = 0;
 	int zeroI = 0;
 
diff --git a/src/heuristicFunctions.hpp b/src/heuristicFunctions.hpp
index 84cc0e1..c458f26 100644
--- a/src/heuristicFunctions.hpp
+++ b/src/heuristicFunctions.hpp
@@ -3,14 +3,14 @@
 
 #include <cstdint>
 
-int	misplacedTiles(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize);
+int	misplacedTiles(const int *map, const int *finishMap, int mapSize);
 
-int	manhattanDistance(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize);
+int	manhattanDistance(const int *map, const int *finishMap, int mapSize);
 
-int	MDplusLinearConflicts(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize);
+int	MDplusLinearConflicts(const int *map, const int *finishMap, int mapSize);
 
-int	MTplusLinearConflicts(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize);
+int	MTplusLinearConflicts(const int *map, const int *finishMap, int mapSize);
 
-int	nMaxSwap(const uint8_t *map, const uint8_t *finishMap, uint8_t mapSize);
+int	nMaxSwap(const int *map, const int *finishMap, int mapSize);
 
 #endif //N_PUZZLE_HEURISTICFUNCTIONS_HPP
diff --git a/src/main_thread_test.cpp b/src/main_thread_test.cpp
index b2ed074..dff858d 100644
--- a/src/main_thread_test.cpp
+++ b/src/main_thread_test.cpp
@@ -114,7 +114,7 @@ int		main() {
 
 #endif // RVALUE_TEST
 
-#define sNAIL_TEST
+//#define sNAIL_TEST
 #ifdef sNAIL_TEST
 
 #include <utility>
@@ -180,3 +180,34 @@ int		main() {
 }
 
 #endif // sNAIL_TEST
+
+#define STATE_TEMPLATE
+#ifdef STATE_TEMPLATE
+
+#include <vector>
+
+class State {
+	std::vector<int> arr;
+public:
+	State(int a) {
+		arr.reserve(a);
+		for (int i = 0; i < a; i++) {
+			arr[i] = a;
+			std::cout << a << ", ";
+		}
+	}
+};
+
+int foo(const int a) {
+	State arr(a);
+}
+
+int main(void) {
+	int a;
+
+	std::cin >> a;
+	foo(a);
+	return (0);
+}
+
+#endif // STATE_TEMPLATE
